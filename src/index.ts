import * as fs from "fs";
import * as path from "path";
import chalk from "chalk";
import chokidar from "chokidar";
import CONFIG from "./config";
import { createLLMProvider, DocSection } from "./llm";
import { ContextManager } from "./vectorstore";
import { ensureEnvFile } from "./config";

// Define document structure type for type safety
type DocStructure = {
	[key: string]: {
		filename: string;
		title: string;
		description: string;
	};
};

// Initialize markdown content cache
let markdownContentCache: Record<string, string> = {};

// Track if update is already in progress
let updateInProgress = false;

/**
 * Ensure .gitignore has necessary entries
 */
function ensureGitIgnore(): void {
	const gitignorePath = path.join(process.cwd(), ".gitignore");

	// Check if .gitignore exists
	if (fs.existsSync(gitignorePath)) {
		let content = fs.readFileSync(gitignorePath, "utf8");
		let modified = false;

		// Check for .context-db
		if (!content.includes(".context-db")) {
			content += content.endsWith("\n") ? ".context-db/\n" : "\n.context-db/\n";
			modified = true;
		}

		// Check for output directory
		const outputDir = path.basename(CONFIG.outputPath);
		if (!content.includes(outputDir)) {
			content += content.endsWith("\n") ? `${outputDir}/\n` : `\n${outputDir}/\n`;
			modified = true;
		}

		// Save changes if needed
		if (modified) {
			fs.writeFileSync(gitignorePath, content);
			console.log(chalk.green("Updated .gitignore with necessary entries"));
		}
	} else {
		console.log(chalk.yellow("No .gitignore file found. Consider creating one."));
	}
}

/**
 * Initialize the documentation directory
 */
function initializeDocDirectory(): void {
	// Create output directory if it doesn't exist
	if (!fs.existsSync(CONFIG.outputPath)) {
		fs.mkdirSync(CONFIG.outputPath, { recursive: true });
		console.log(chalk.green(`Created documentation directory at ${CONFIG.outputPath}`));
	}

	// Create README.md in the directory that lists all documentation files
	const readmePath = path.join(CONFIG.outputPath, "README.md");
	const readmeContent = `# Project Documentation

This directory contains automated documentation for the project, generated by project-context-to-md-file.

## Documentation Sections

${Object.entries(CONFIG.docStructure as DocStructure)
	.map(([key, section]) => `- [${section.title}](${section.filename}) - ${section.description}`)
	.join("\n")}

The documentation is automatically updated as the project changes.
`;

	fs.writeFileSync(readmePath, readmeContent);
	console.log(chalk.green(`Created README.md in documentation directory`));
}

/**
 * Generate markdown content for all documentation sections
 */
async function generateMarkdown(): Promise<Record<string, string>> {
	// Create LLM provider
	const llmProvider = createLLMProvider();

	// Generate initial context
	const contextManager = new ContextManager(process.cwd(), CONFIG.outputPath, CONFIG.maxTokens);
	await contextManager.initialize();

	console.log(chalk.blue("Collecting initial project context..."));

	// Initialize content object for all sections
	const generatedContent: Record<string, string> = {};

	// Prepare document sections
	const sections: DocSection[] = Object.entries(CONFIG.docStructure as DocStructure).map(([key, section]) => ({
		key,
		filename: section.filename,
		title: section.title,
		description: section.description,
		content: "",
	}));

	// Generate content for each section
	for (const section of sections) {
		// Build context for this specific section
		const context = await contextManager.buildSectionContext(section.key);

		// Generate content using LLM
		section.content = await llmProvider.generateContent(context, section.key);

		// Store in our content dictionary
		generatedContent[section.key] = section.content;
	}

	return generatedContent;
}

/**
 * Update markdown content for all sections
 */
async function updateMarkdown(): Promise<void> {
	if (updateInProgress) {
		console.log(chalk.yellow("Update already in progress. Skipping this update cycle."));
		return;
	}

	updateInProgress = true;
	console.log(chalk.blue("Starting documentation update..."));

	try {
		// Generate content for all sections
		const generatedContent = await generateMarkdown();

		// Write each section to its own file
		await writeMarkdownFiles(generatedContent);

		console.log(chalk.green("Documentation update completed."));
	} catch (error) {
		console.error(chalk.red("Error updating documentation:"), error);
	} finally {
		updateInProgress = false;
	}
}

/**
 * Write markdown content to files
 */
async function writeMarkdownFiles(content: Record<string, string>): Promise<void> {
	// Create output directory if it doesn't exist
	if (!fs.existsSync(CONFIG.outputPath)) {
		fs.mkdirSync(CONFIG.outputPath, { recursive: true });
	}

	// Write each section to its own file
	for (const [key, sectionContent] of Object.entries(content)) {
		const docStructure = CONFIG.docStructure as DocStructure;
		const section = docStructure[key];
		if (!section) continue;

		const filePath = path.join(CONFIG.outputPath, section.filename);

		// Only write if content has changed
		if (markdownContentCache[key] !== sectionContent) {
			fs.writeFileSync(filePath, sectionContent);
			markdownContentCache[key] = sectionContent;
			console.log(chalk.green(`Updated documentation file at ${filePath}`));
		}
	}
}

/**
 * Watch for file changes
 */
function watchFiles(): void {
	// Ignore the output directory and node_modules
	const ignoredPatterns = [CONFIG.outputPath, "node_modules/**", ".git/**"];

	console.log(chalk.blue("Watching for file changes..."));

	// Create a file watcher
	const watcher = chokidar.watch(".", {
		ignored: ignoredPatterns,
		persistent: true,
		ignoreInitial: true,
	});

	// Handle file changes
	watcher.on("all", (event, filepath) => {
		// Don't react to changes in the output directory
		if (filepath.startsWith(CONFIG.outputPath)) {
			return;
		}

		console.log(chalk.yellow(`Project files changed (${event}: ${filepath}), updating documentation...`));
		updateMarkdown();
	});

	// Also set up a periodic update
	setInterval(() => {
		console.log(chalk.blue("Scheduled update triggered..."));
		updateMarkdown();
	}, CONFIG.updateInterval);
}

/**
 * Main function
 */
async function main(): Promise<void> {
	console.log(chalk.blue("Starting project-context-to-md-file service"));
	console.log(`Output directory: ${CONFIG.outputPath}`);
	console.log(`Update interval: ${CONFIG.updateInterval}ms`);
	console.log(`LLM Provider: ${CONFIG.llmProvider}`);
	console.log(`LLM Model: ${CONFIG.llmModel}`);
	console.log(`Max tokens for context: ${CONFIG.maxTokens}`);

	// Ensure we have an env file
	ensureEnvFile();

	// Ensure .gitignore has necessary entries
	ensureGitIgnore();

	// Initialize the documentation directory
	initializeDocDirectory();

	// Generate initial markdown
	await updateMarkdown();

	// Start watching for changes
	watchFiles();
}

// Run the program
main().catch((error) => {
	console.error(chalk.red("Fatal error:"), error);
	process.exit(1);
});
